import numpy as np

PN_res_set = False
PN_res = None

def PinknoiseSG(DIM, BETA):
     """
     This function generates 1/f spatial noise, with a normal error 
     distribution (the grid must be at least 10x10 for the errors to be normal). 
     1/f noise is scale invariant, there is no spatial scale for which the 
     variance plateaus out, so the process is non-stationary.

     DIM is a two component vector that sets the size of the spatial pattern
          (DIM=[10,5] is a 10x5 spatial grid)
     BETA defines the spectral distribution. 
          Spectral density S(f) = N f^BETA
          (f is the frequency, N is normalisation coeff).
               BETA = 0 is random white noise.  
               BETA  -1 is pink noise
               BETA = -2 is Brownian noise
          The fractal dimension is related to BETA by, D = (6+BETA)/2

     Note that the spatial pattern is periodic.  If this is not wanted the
     grid size should be doubled and only the first quadrant used.

     Time series can be generated by setting one component of DIM to 1
     """
     global PN_res, PN_res_set
     if PN_res_set:
          return PN_res

     # Generate the grid of frequencies. u is the set of frequencies along the first dimension
     u = np.fft.fftfreq(DIM[0]).reshape(-1, 1)
     # Reproduce these frequencies along every row
     u = np.tile(u, (1, DIM[1]))
     # v is the set of frequencies along the second dimension. For a square region it will be the transpose of u
     v = np.fft.fftfreq(DIM[1]).reshape(1, -1)
     # Reproduce these frequencies along every column
     v = np.tile(v, (DIM[0], 1))

     # Generate the power spectrum
     epsilon = 1e-10  # Small value to avoid division by zero
     S_f = (u**2 + v**2 + epsilon)**(BETA/2)

     # Set any infinities to zero
     S_f[S_f == np.inf] = 0

     # Generate a grid of random phase shifts
     phi = np.random.rand(*DIM)

     # Inverse Fourier transform to obtain the spatial pattern
     x = np.fft.ifft2(S_f**0.5 * (np.cos(2 * np.pi * phi) + 1j * np.sin(2 * np.pi * phi)))

     # Pick just the real component
     x = np.real(x)

     # Transform to [0 1] range
     x = (x - x.min()) / (x.max() - x.min())

     # Scale to [-1, 1] range
     x = x * 2 - 1

     PN_res = x
     PN_res_set = True
     return x

if __name__ == "__main__":
    import matplotlib.pyplot as plt

    DIM = [100, 100]
    BETA = -1

    noise = PinknoiseSG(DIM, BETA)

    plt.imshow(noise, cmap='gray')
    plt.show()



